---
title: "进程原理、类型及内核状态"
date: 2020-10-04T09:03:20-08:00
draft: true
tags: [进程,linux]
---

# 库调用，系统调用，混合调用

## 库调用

- 直接在根目录下的 lib 目录下调用函数库来实现功能
- 库调用的很多功能仍然会有一部分包含了系统调用
- 有些是一个独立的模块，而有些只是系统调用的二次封装

## 系统调用

- 直接调用内核中的模块

## 混合调用

- 程序员在编程时不仅调用了系统模块，也调用了 lib 目录下的函数库

# 程序运行时发起调用意味着什么？

CPU的指令分为普通指令和特权指令

内核和普通应用程序的区别

- 特权指令通常是内核来调用的，并且是直接运行
- 任何程序只要用到特权指令那么就要调用内核提供的系统调用

## 程序运行的过程

如果程序可以自己执行，那么自己将请求发送到 CPU 进行执行，如果自己没有权限来执行，那么就要发起一次软中断（软中断的作用就是用来发起系统调用），通过让内核将特权执行发送到 CPU 来执行。

## 程序运行的实际逻辑

就是在用户模式和内核模式之间来回转换，这一过程称为模式切换

- 用户模式（空间）：运行用户代码那么就是在用户模式中运行
- 内核模式（空间）：运行的就是内核指令，管理硬件的只有内核来完成

### 用户模式的功用

只有用户模式运行的用户代码会运行生产功能

百分之七十都会在用户模式下运行

### 内核模式的功用

百分之三十会在内核模式下运行

进程管理：进程的创建、销毁、查看都是在内核中运行

文件系统

网络功能：TCP/IP 协议栈都是在内核中实现的，是一个公共功能，不是库来实现，因为网络功能需要调用大量的硬件功能，可以模式在用户模式实现

内存管理

驱动程序

安全功能

### 用户模式与内核模式的关系

用户模式中运行的用户代码只要需要用到模式中的功用，那么就需要来调用内核模式中的相关模块来通过内核模式来实现。

## 一颗 CPU 是怎么同时运行的多个进程

通过时间片来切换进程的运行，通过优先级来判断进程的运行先后顺序。

由上一个进程切换到下一个进程时，为了不丢失上一个进程运行产生的数据内核会生成一个保存线程。当上一个进程继续运行时会恢复该保存线程这个过程称为恢复线程。

# 进程的概念

## Process：运行中程序的一个副本。

- 有自己的生命周期，进程是一个活动的主体。而程序是一个文件。
  - 进程有自己的运行期，启动期创建期和终止期。
- 副本：同一个执行文件，可以运行多次。例如 ls 命令，可以执行多次运行。

## linux 内核存储进程信息的固定格式

- 多个任务的 task struct 组件的链表，task list

- 通过 C 语言的结构体规定

## 如果有进程想脱离内核

当用户空间中的进程要执行 CPU 的特权指令时，那么 CPU 会自动唤起内核（CPU 会发起软中断，这个软中断只有内核可以解决）

## init 进程的产生

系统开机时会内核会首先开启，并且创建用户空间和内核空间。创建完成后会在用户空间创建一个 init 进程，这个进程不能替代内核来完成 CPU 特殊指令的进行，但是会
管理一切用户空间的内容。

- 创建进程时会提交给内核
- 负责一切用户空间进程管理

## 进程创建

进程是有父子关系的

### init 进程是第一个进程
- 进程都是由父进程创建
  - fork() 内核的系统调用，只要父进程要创建子进程就要向内核发起 fork() 的系统调用
  - clone() 父进程克隆自己本身数据给子进程

## 父子进程概念

子进程都是由父进程来创建的

- 父进程创建子进程的时候会调用内核的 fork() 系统调用，并且会向内核发起请求。
- 父进程通常还会调用 clone() 克隆自身数据给子进程
- 子进程与父进程使用的是同一块内存空间

### Cow机制

写时复制，会为子进程创建一个单独的内存空间，写入数据时子进程不会与父进程使用同一个内存空间，拥有单独的内存空间。

# 进程优先级

## 1-99 实时优先级

- 数字越大优先级越高

## 100-139 静态优先级

- 数字越小，优先级越高

### Nice 值

nice 值的 -20-19 对应的就是静态优先级的数值大小，负的优先级会高于正数的优先级。如果将一个进程的 nice 值设为 -20，那就表明该进程会变得无比重要，但是如果将一个进程的 nice 值设为 19，就表明该进程是一个无私的值，该进程可以将资源让给其他资源，并且自己只会占用一小部分资源份额。

子进程会继承父进程的 nice 值。

## 内核判断优先级方式

通过将所有进程分为 140 列，然后再通过通过优先级的高低来判断运行哪一列，找到运行的那列开始自上而下执行。

## Big O 标准

用来衡量一个算法执行时间以及一个算法好坏的标准。函数衡量法则。

- O(1) 无论你的数据量有多复杂或者是有多少，使用的时间都是相同的，最理想标准。
- O(logn) 刚开始比较急剧后来会慢慢趋于平缓
- O(n) 线性复杂度，数据量上升复杂度就会上升，

## 过期队列的产生

每次在一个运行队列的进程运行处理后就会放到最后的过期队列中。

# 进程内存

不同程序占用的内存空间是不同的

## 内存的最小单位

page frame 页框

- 存储页面数据，使用内存的数据就称之为是页面数据。

## 虚拟内存的产生

为了完成内核对进程的多任务管理，内核或者说是操作系统会将物理内存分割成一个一个的块，一般情况是 4k 称为 page frame 页框，存储页面数据（使用内存的数据就称为页面数据）。但是每个分配的物理内存页有可能是连续的也有可能是不连续的，如果是不连续的，那么就会将多个页组成一个虚拟内存分配给一个进程使用。

## 内核对进程的小套路

每次创建进程时，就会告诉新创建的进程所有可用的内存空间有多少，然后进程就会相信那么大的空间都是自己的。并且内核每次创建进程都会这么去告诉。可谓是渣到不能再渣。这种管理方法就称为线性内存管理机制。

每一个进程以为自己所拥有的全部内存空间就称为线性地址空间。线性地址和物理内存的对应有可能是离散对应的。所以就需要内核来伪装成一个完整的虚拟内存空间提供给进程。这就称为虚拟内存实现机制。线性空间与物理空间是存在映射关系的。

# LRU 算法的应用

## LRU 解决当物理内存空间用光后踢出的进程？

LRU 算法称为最近最少使用算法，物理内存真的用光后，那么就会采用 LRU 算法查看每个 page frame (内存页)最近的使用次数以及使用的频率，将使用次数以及频率较少的 page frame 内存页转移到交换分区运行，如果有程序再次使用到该进程或者是 page frame 内存页时会重新从交换分区中加载到内存中运行，再次采用 LRU 算法计算并将其转移到交换分区为已经被调用的进程腾出空间。

## MMU 的应用

MMU——内存管理单元（硬件）

### MMU 解决进程从物理内存移动到虚拟内存，然后再从虚拟内存中将进程移动到物理内存中运行时线性空间与物理空间的映射关系被破坏的问题？

内核为每个进程都准备了一个存储映射地址的存储空间，称为 task struct 其中记录了每一个进程的线性地址对应的物理地址空间的映射关系。每次进程运行时，存储和读取数据都是通过查看 task struct 找到线性地址空间对应的物理空间来读取物理空间中数据的。MMU 负责同步存储解决映射关系。

缺页异常：通过虚拟内存和物理内存之间的转换导致的进程找不到物理内存对应的数据，导致的问题。

# IPC 的应用

进程间通信机制

## 同一主机

- signal 信号通信
- shm 共享内存方式
- semerphor

## 不同主机

- rpc remote procecure call
- socket 套接字文件进行通信，实质上就是一端在执行 write 写的操作，另一端在执行 read 的操作，这样就实现了不同主机之间通信

# linux 内核工作模式

## 抢占式多任务

例如每个时间点进程运行的一段时间后都会给其他进程一个抢占的机会，如果抢占成功，那么该进程运行一段时间，再给予其他等待的进程一个抢占的机会。

# 进程类型

守护进程：daemon，与终端无关，在系统引导过程中启动的进程

用户进程（前台进程）：用户通过终端启动的进程，与终端相关

也可以把在前台启动的进程送到后台，以守护进程的方式来运行，例如 systemctl start [service|socket]

# 进程状态

运行态：running

就绪态：ready

睡眠态：

可中断睡眠：interruptable（此状态在运行时任何程序都可以直接终止睡眠状态，并且让其转换为工作状态）
不可中断睡眠：uninterruptable
停止态：暂停到内存中，不会被调度，除非手动唤醒 stopped

僵死态：zombie

# I/O过程

1. 将磁盘中的数据加载到内核内存中
2. 内核内存将磁盘中的数据复制一份到进程内存中
3. 进程读取数据

# 进程的分类

- CPU-BOUND CPU 密集型的进程
- IO-BOUND I/O 读写密集型